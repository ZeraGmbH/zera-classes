#include <gtest/gtest.h>
#include <QString>
#include "zera_mcontroller_errorflags.h"

#define GTEST_OUT std::cerr << "[ OUT      ] "

// These look odd but as long as firmware update scripts in meta-zera check
// for the output of zera-mcontroller-io we have to make sure output is stable
// whatever changes we modify in ZeraMcontrollerErrorFlags

TEST(TEST_ZERA_I2C, ERROR_MASK_ZERO_HARD) {
    QString maskText = ZeraMcontrollerErrorFlags::getErrorMaskText(0, false);
    EXPECT_STREQ(qPrintable(maskText), "host-mask 0x0000 / µC-mask 0x0000");
}

TEST(TEST_ZERA_I2C, ERROR_MASK_ZERO_BOOT) {
    QString maskText = ZeraMcontrollerErrorFlags::getErrorMaskText(0, true);
    EXPECT_STREQ(qPrintable(maskText), "host-mask 0x0000 / µC-mask 0x0000");
}

TEST(TEST_ZERA_I2C, ERROR_MASK_UPPER_HARD) {
    QString maskText = ZeraMcontrollerErrorFlags::getErrorMaskText(0xFFFF0000, false);
    EXPECT_STREQ(qPrintable(maskText), "host-mask 0xFFFF / µC-mask 0x0000 / MASTER_ERR_FLAG_I2C_TRANSFER | MASTER_ERR_FLAG_CRC | MASTER_ERR_FLAG_LENGTH | MASTER_ERR_FLAG_VERIFY_BLOCK | MASTER_ERR_FLAG_FLASH_WRITE | MASTER_ERR_FLAG_EERPOM_WRITE | MASTER_ERR_FLAG_FLASH_VERIFY | MASTER_ERR_FLAG_EERPOM_VERIFY | UNDEFINED_ERROR_BIT_24 | UNDEFINED_ERROR_BIT_25 | UNDEFINED_ERROR_BIT_26 | UNDEFINED_ERROR_BIT_27 | UNDEFINED_ERROR_BIT_28 | UNDEFINED_ERROR_BIT_29 | UNDEFINED_ERROR_BIT_30 | MASTER_ERR_FLAG_CODER_IS_AN_IDIOT");
}

TEST(TEST_ZERA_I2C, ERROR_MASK_UPPER_BOOT) {
    QString maskText = ZeraMcontrollerErrorFlags::getErrorMaskText(0xFFFF0000, true);
    EXPECT_STREQ(qPrintable(maskText), "host-mask 0xFFFF / µC-mask 0x0000 / MASTER_ERR_FLAG_I2C_TRANSFER | MASTER_ERR_FLAG_CRC | MASTER_ERR_FLAG_LENGTH | MASTER_ERR_FLAG_VERIFY_BLOCK | MASTER_ERR_FLAG_FLASH_WRITE | MASTER_ERR_FLAG_EERPOM_WRITE | MASTER_ERR_FLAG_FLASH_VERIFY | MASTER_ERR_FLAG_EERPOM_VERIFY | UNDEFINED_ERROR_BIT_24 | UNDEFINED_ERROR_BIT_25 | UNDEFINED_ERROR_BIT_26 | UNDEFINED_ERROR_BIT_27 | UNDEFINED_ERROR_BIT_28 | UNDEFINED_ERROR_BIT_29 | UNDEFINED_ERROR_BIT_30 | MASTER_ERR_FLAG_CODER_IS_AN_IDIOT");
}

TEST(TEST_ZERA_I2C, ERROR_MASK_LOWER_HARD) {
    QString maskText = ZeraMcontrollerErrorFlags::getErrorMaskText(0x0000FFFF, false);
    EXPECT_STREQ(qPrintable(maskText), "host-mask 0x0000 / µC-mask 0xFFFF / HW_ERR_FLAG_CRC | HW_ERR_FLAG_LENGTH | HW_ERR_CMD_FOR_DEV_NOT_AVAIL | HW_ERR_FLAG_EXECUTE | HW_ERR_LAYER2 | HW_ERR_PARAM_INVALID | HW_ERR_ASCII_HEX | UNDEFINED_ERROR_BIT_7 | UNDEFINED_ERROR_BIT_8 | UNDEFINED_ERROR_BIT_9 | UNDEFINED_ERROR_BIT_10 | UNDEFINED_ERROR_BIT_11 | UNDEFINED_ERROR_BIT_12 | UNDEFINED_ERROR_BIT_13 | UNDEFINED_ERROR_BIT_14 | UNDEFINED_ERROR_BIT_15");
}

TEST(TEST_ZERA_I2C, ERROR_MASK_LOWER_BOOT) {
    QString maskText = ZeraMcontrollerErrorFlags::getErrorMaskText(0x0000FFFF, true);
    //GTEST_OUT << qPrintable(maskText) << std::endl;
    EXPECT_STREQ(qPrintable(maskText), "host-mask 0x0000 / µC-mask 0xFFFF / BL_ERR_FLAG_BUFFER_OVERFLOW | BL_ERR_FLAG_HEX_INVALID | BL_ERR_FLAG_LENGTH | BL_ERR_FLAG_CRC | BL_ERR_FLAG_CMD_INVALID | BL_ERR_FLAG_ADR_RANGE | BL_ERR_FLAG_EXECUTE | UNDEFINED_ERROR_BIT_7 | UNDEFINED_ERROR_BIT_8 | UNDEFINED_ERROR_BIT_9 | UNDEFINED_ERROR_BIT_10 | UNDEFINED_ERROR_BIT_11 | UNDEFINED_ERROR_BIT_12 | UNDEFINED_ERROR_BIT_13 | UNDEFINED_ERROR_BIT_14 | UNDEFINED_ERROR_BIT_15");
}

